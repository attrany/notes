{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/journal/source/css/journal.css","path":"css/journal.css","modified":0,"renderable":1},{"_id":"themes/journal/source/js/journal.js","path":"js/journal.js","modified":0,"renderable":1},{"_id":"themes/journal/source/js/loadCSS.js","path":"js/loadCSS.js","modified":0,"renderable":1},{"_id":"themes/journal/source/scss/journal.scss","path":"scss/journal.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/journal/.gitignore","hash":"2915cafb34810987f93370b9676d0117854c82be","modified":1555840174000},{"_id":"themes/journal/CHANGELOG.md","hash":"392ef99088094d9e56f4e2eb7388eb5b95a29e9a","modified":1555840174000},{"_id":"themes/journal/LICENSE","hash":"7f1ccd69ff0a6cf530530596f34c3396cd5989ba","modified":1555840174000},{"_id":"themes/journal/README.md","hash":"03c97701d3023fed2b74716b43b0cf37d24b306a","modified":1555840174000},{"_id":"themes/journal/_config.yml","hash":"2718bc8db93f2f60233a4bb72a6974bad4b9d893","modified":1557234125265},{"_id":"themes/journal/package.json","hash":"827282095506814c685957f0cdff081fa04ecb09","modified":1555840174000},{"_id":"source/_posts/post.md","hash":"289a2146a1840507cf0e24667bda1c1f5ec13332","modified":1557233657056},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1557233472426},{"_id":"source/_posts/restore.md","hash":"d2eac2de9417b2e69e993a8b4ac60c95d2c0c30b","modified":1557233472426},{"_id":"themes/journal/package-lock.json","hash":"581d84d0b5d0cd6a9d9b808cfb4cd227169a0421","modified":1555840174000},{"_id":"themes/journal/yarn.lock","hash":"a472e4a17038d782b3178a96948ac209c80e665a","modified":1555840174000},{"_id":"themes/journal/arts/title.png","hash":"efa6efb312b0132d6a0b823cf6498afa53a27486","modified":1555840174000},{"_id":"themes/journal/languages/ja.yml","hash":"bf959c6395a08813ddc642612d45b395cb6f881f","modified":1555840174000},{"_id":"themes/journal/languages/en.yml","hash":"eaa4a5a47ea735b6e9732d36ea99ce14fa029590","modified":1555840174000},{"_id":"themes/journal/languages/zh-CN.yml","hash":"bcbf8308dbfb7cde07678f79fb650aeddd24f9ac","modified":1555840174000},{"_id":"themes/journal/languages/zh-TW.yml","hash":"229aec9583da5d362bf51b000d2f930770e5bd1a","modified":1555840174000},{"_id":"themes/journal/layout/category-index.ejs","hash":"48cda7367c01643e0a6e240fd48864f3fec34a87","modified":1555840174000},{"_id":"themes/journal/layout/archive.ejs","hash":"dd986e9eadca53b32462b9017d38161f998e2ef4","modified":1555840174000},{"_id":"themes/journal/layout/category.ejs","hash":"17c87f0d428aece08d1a67837f821bc2c8998abd","modified":1555840174000},{"_id":"themes/journal/layout/index.ejs","hash":"fbcd603c70e36837b0823bea5d30fbb9f960e188","modified":1557237802415},{"_id":"themes/journal/layout/page.ejs","hash":"a7902e5916da0482aade152a366099268400f542","modified":1555840174000},{"_id":"themes/journal/layout/post.ejs","hash":"81cb7890d196023030ab78ad17944341c3c17eac","modified":1557237827383},{"_id":"themes/journal/layout/tag-index.ejs","hash":"116851d25720635b3336a6f47800bcba7dc5775c","modified":1555840174000},{"_id":"themes/journal/layout/skeleton.ejs","hash":"a6d7f377a449ff49fc6a12ef5d62d6d00f3de462","modified":1555840174000},{"_id":"themes/journal/layout/tag.ejs","hash":"6f9a9253c502ecdc87b0a20e4fab86350c50354b","modified":1555840174000},{"_id":"themes/journal/layout/_include/body_includes.ejs","hash":"b4cbb1b7e3a7b7cf446815b206bf2c4099a49c24","modified":1555840174000},{"_id":"themes/journal/layout/_include/comment_includes.ejs","hash":"786012aa2d6fff3c60bb93effc7bc5014f651051","modified":1555840174000},{"_id":"themes/journal/layout/_include/comment_templates.ejs","hash":"b3a0adfa9efe8be02301818d92a1e6f77af4dd5c","modified":1555840174000},{"_id":"themes/journal/layout/_include/container_head.ejs","hash":"3077611ad9e79fbc9e2b1614b8695926fab213c6","modified":1555840174000},{"_id":"themes/journal/layout/_include/extra_nav.ejs","hash":"d16fd03720bcc3c5906db5f25c637a0cb14c542c","modified":1555840174000},{"_id":"themes/journal/layout/_include/container_tail.ejs","hash":"94f583f62db3f44a703e243b8e4d4b5dfd358dca","modified":1555840174000},{"_id":"themes/journal/layout/_include/head.ejs","hash":"ff9db3ba3e68af373d61d737342c3c7ea4f6a173","modified":1555840174000},{"_id":"themes/journal/layout/_include/head_includes.ejs","hash":"c3009fcdc4615062da467e11f853a3663d728147","modified":1555840174000},{"_id":"themes/journal/layout/_include/head_meta.ejs","hash":"b7b71106466427449cb97a18759f2d75c5018320","modified":1555840174000},{"_id":"themes/journal/layout/_include/pagination.ejs","hash":"f35ee834ed37417ebd1fd3cf093cf13acde1a42c","modified":1555840174000},{"_id":"themes/journal/layout/_include/post_pagination.ejs","hash":"f4bdf12ffa0d8f7bb97ba8a7f292d143aafd76d3","modified":1555840174000},{"_id":"themes/journal/layout/_include/side_nav.ejs","hash":"d3f52720d3a6b609d546a726024a6a9d4d904051","modified":1555840174000},{"_id":"themes/journal/layout/_include/single_column_footer.ejs","hash":"09b03c265ba087bf0d83e8a679248abb72c230fa","modified":1555840174000},{"_id":"themes/journal/layout/_include/tail.ejs","hash":"f5469d5a3fcc8d788a8c5529506b44dad3afeacd","modified":1555840174000},{"_id":"themes/journal/layout/_include/variables.ejs","hash":"a46f7b6648dd78ac2c24d88b515b4f64bb2de9f3","modified":1555840174000},{"_id":"themes/journal/layout/_include/single_column_head.ejs","hash":"db3c97713cd06936b1c84a9009e7d6606fec0e79","modified":1555840174000},{"_id":"themes/journal/source/css/journal.css","hash":"0c5f47e5963355c896b878738a2330d305166d57","modified":1555840174000},{"_id":"themes/journal/source/js/journal.js","hash":"3bb0e1bc855fe853469fd5e8934d7b429e8f4390","modified":1555840174000},{"_id":"themes/journal/source/js/loadCSS.js","hash":"c7488687767f8a63f1301374eafd8443f3e4430a","modified":1555840174000},{"_id":"themes/journal/source/scss/journal.scss","hash":"19025998ba9e045849909ea14783d462b0b3a916","modified":1555840174000},{"_id":"themes/journal/arts/post_item.png","hash":"d7835296e68965004f4b61a8445e12f343bf06b1","modified":1555840174000},{"_id":"themes/journal/arts/screenshot.png","hash":"9adf517c4754018f247b424d49e466cacbe69bba","modified":1555840174000},{"_id":"themes/journal/arts/wxpay.png","hash":"3c81a7f859e8a32a0b06e42a90c25e11e458494d","modified":1555840174000},{"_id":"source/_posts/build-android-project-by-gitlab-ci.md","hash":"fd4be33539886da3fbcadd2ba50f68a5e8d55a45","modified":1557237264273},{"_id":"source/_posts/access-contents-of-a-kvm-image.md","hash":"dcd837f0551791079573e2a1d2bd71e17f9adbcf","modified":1557238378955}],"Category":[{"name":"搬砖日常","_id":"cjvdt6ric0002k7y9jsjx9e9y"},{"name":"工作日常","_id":"cjvdtcrrx000uk7y9a7kkfaxd"}],"Data":[],"Page":[],"Post":[{"title":"post","date":"2019-05-07T12:54:17.000Z","_content":"","source":"_posts/post.md","raw":"---\ntitle: post\ndate: 2019-05-07 20:54:17\ntags:\n---\n","slug":"post","published":1,"updated":"2019-05-07T12:54:17.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvdssy7x0000fjy93rviamyo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"开启新篇章","date":"2019-04-30T10:44:28.000Z","_content":"\n我是测试内容\n","source":"_posts/restore.md","raw":"---\ntitle: 开启新篇章\ndate: 2019-04-30 18:44:28\ntags: feafe\n---\n\n我是测试内容\n","slug":"restore","published":1,"updated":"2019-05-07T12:51:12.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvdssy830002fjy9zgg80ip0","content":"<p>我是测试内容</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我是测试内容</p>\n"},{"title":"使用gitlab-ci进行android项目构建","date":"2017-03-02T06:53:37.000Z","featured_image":"https://attrany.oss-cn-beijing.aliyuncs.com/notes/20190507215118.png","_content":"\n## 背景\n最近接了一个android内部应用的活，但是每次给别人试用的时候都是在本地打个包，然后用邮件或者IM传给大家。\n效率低下，而且没有版本追踪。于是想到了CI。\n之前用CI仅仅是跑一些自动测试，没有进行过android项目的打包发布的经历，不过感觉应该不难。\n大致思路为：\n代码合并至RELEASE分支 -> 触发一个WebHook通知CI构建 -> CI构建并完成打包 -> 发布程序\n手头没有jenkins，而且刚好之前看到gitlab集成了ci功能，就想尝尝鲜。\n\n## 配置构建环境\n经过研究，gitlab-ci采用分布式构建模式，也就是构建过程是跑在不同的构建主机上的。\n构建主机需要运行gitlab-ci-runner进程，与gitlab服务端进行通信，以接收并执行分派给该进程的构建任务。\n跑构建的主机上可以部署gitlab-ci-runner程序，使用gitlab项目中配置的token启动以后，该runner会自动出现在gitlab服务端的项目视图中。\n进入gitlab项目页面->设置下拉列表->runners即可看到\n\n我厂的gitlab已经配置好了2个\n\n## 创建构建配置文件\ngitlab-ci的构建过程是在配置文件中配置合描述的。\n那么接下来，在项目根目录创建.gitlab-ci.yml文件\n配置文件可以包含如下几个段落\nvariables\nbefore_script\nstages\nbuild\n我们的项目需要进行如下步骤\n编译打包 -> 发布程序\n所以我们在build下面配置如下步骤\n```\nbuild:\n  stage: build\n  script:\n    - ./gradlew assembleRelease\n    - DATE=`date +%Y%m%d%H%M%S`\n    - rsync ./app/build/outputs/apk/app-release.apk work@publish-server:/home/work/data/www/publish-site/app/mtaa/mtaa_${DATE}.apk\n    - ssh work@publish-server \"cd /home/work/data/www/publish-site/app/mtaa; cp -f mtaa_${DATE}.apk mtaa.apk\"\n\n  artifacts:\n    paths:\n    - app/build/outputs/\n```\n\n## 效果\n构建过程\n构建结果\n发布结果\n大家终于可以扫码下载最新版应用啦","source":"_posts/build-android-project-by-gitlab-ci.md","raw":"---\ntitle: 使用gitlab-ci进行android项目构建\ndate: 2017-03-02 14:53:37\ntags: [gitlab, ci, gitlab-ci, android, build, 构建, 打包]\ncategory: 工作日常\nfeatured_image: https://attrany.oss-cn-beijing.aliyuncs.com/notes/20190507215118.png\n---\n\n## 背景\n最近接了一个android内部应用的活，但是每次给别人试用的时候都是在本地打个包，然后用邮件或者IM传给大家。\n效率低下，而且没有版本追踪。于是想到了CI。\n之前用CI仅仅是跑一些自动测试，没有进行过android项目的打包发布的经历，不过感觉应该不难。\n大致思路为：\n代码合并至RELEASE分支 -> 触发一个WebHook通知CI构建 -> CI构建并完成打包 -> 发布程序\n手头没有jenkins，而且刚好之前看到gitlab集成了ci功能，就想尝尝鲜。\n\n## 配置构建环境\n经过研究，gitlab-ci采用分布式构建模式，也就是构建过程是跑在不同的构建主机上的。\n构建主机需要运行gitlab-ci-runner进程，与gitlab服务端进行通信，以接收并执行分派给该进程的构建任务。\n跑构建的主机上可以部署gitlab-ci-runner程序，使用gitlab项目中配置的token启动以后，该runner会自动出现在gitlab服务端的项目视图中。\n进入gitlab项目页面->设置下拉列表->runners即可看到\n\n我厂的gitlab已经配置好了2个\n\n## 创建构建配置文件\ngitlab-ci的构建过程是在配置文件中配置合描述的。\n那么接下来，在项目根目录创建.gitlab-ci.yml文件\n配置文件可以包含如下几个段落\nvariables\nbefore_script\nstages\nbuild\n我们的项目需要进行如下步骤\n编译打包 -> 发布程序\n所以我们在build下面配置如下步骤\n```\nbuild:\n  stage: build\n  script:\n    - ./gradlew assembleRelease\n    - DATE=`date +%Y%m%d%H%M%S`\n    - rsync ./app/build/outputs/apk/app-release.apk work@publish-server:/home/work/data/www/publish-site/app/mtaa/mtaa_${DATE}.apk\n    - ssh work@publish-server \"cd /home/work/data/www/publish-site/app/mtaa; cp -f mtaa_${DATE}.apk mtaa.apk\"\n\n  artifacts:\n    paths:\n    - app/build/outputs/\n```\n\n## 效果\n构建过程\n构建结果\n发布结果\n大家终于可以扫码下载最新版应用啦","slug":"build-android-project-by-gitlab-ci","published":1,"updated":"2019-05-07T13:54:24.273Z","_id":"cjvdt6ri60000k7y9elth9mzc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近接了一个android内部应用的活，但是每次给别人试用的时候都是在本地打个包，然后用邮件或者IM传给大家。<br>效率低下，而且没有版本追踪。于是想到了CI。<br>之前用CI仅仅是跑一些自动测试，没有进行过android项目的打包发布的经历，不过感觉应该不难。<br>大致思路为：<br>代码合并至RELEASE分支 -&gt; 触发一个WebHook通知CI构建 -&gt; CI构建并完成打包 -&gt; 发布程序<br>手头没有jenkins，而且刚好之前看到gitlab集成了ci功能，就想尝尝鲜。</p>\n<h2 id=\"配置构建环境\"><a href=\"#配置构建环境\" class=\"headerlink\" title=\"配置构建环境\"></a>配置构建环境</h2><p>经过研究，gitlab-ci采用分布式构建模式，也就是构建过程是跑在不同的构建主机上的。<br>构建主机需要运行gitlab-ci-runner进程，与gitlab服务端进行通信，以接收并执行分派给该进程的构建任务。<br>跑构建的主机上可以部署gitlab-ci-runner程序，使用gitlab项目中配置的token启动以后，该runner会自动出现在gitlab服务端的项目视图中。<br>进入gitlab项目页面-&gt;设置下拉列表-&gt;runners即可看到</p>\n<p>我厂的gitlab已经配置好了2个</p>\n<h2 id=\"创建构建配置文件\"><a href=\"#创建构建配置文件\" class=\"headerlink\" title=\"创建构建配置文件\"></a>创建构建配置文件</h2><p>gitlab-ci的构建过程是在配置文件中配置合描述的。<br>那么接下来，在项目根目录创建.gitlab-ci.yml文件<br>配置文件可以包含如下几个段落<br>variables<br>before_script<br>stages<br>build<br>我们的项目需要进行如下步骤<br>编译打包 -&gt; 发布程序<br>所以我们在build下面配置如下步骤<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build:</span><br><span class=\"line\">  stage: build</span><br><span class=\"line\">  script:</span><br><span class=\"line\">    - ./gradlew assembleRelease</span><br><span class=\"line\">    - DATE=`date +%Y%m%d%H%M%S`</span><br><span class=\"line\">    - rsync ./app/build/outputs/apk/app-release.apk work@publish-server:/home/work/data/www/publish-site/app/mtaa/mtaa_$&#123;DATE&#125;.apk</span><br><span class=\"line\">    - ssh work@publish-server &quot;cd /home/work/data/www/publish-site/app/mtaa; cp -f mtaa_$&#123;DATE&#125;.apk mtaa.apk&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  artifacts:</span><br><span class=\"line\">    paths:</span><br><span class=\"line\">    - app/build/outputs/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>构建过程<br>构建结果<br>发布结果<br>大家终于可以扫码下载最新版应用啦</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近接了一个android内部应用的活，但是每次给别人试用的时候都是在本地打个包，然后用邮件或者IM传给大家。<br>效率低下，而且没有版本追踪。于是想到了CI。<br>之前用CI仅仅是跑一些自动测试，没有进行过android项目的打包发布的经历，不过感觉应该不难。<br>大致思路为：<br>代码合并至RELEASE分支 -&gt; 触发一个WebHook通知CI构建 -&gt; CI构建并完成打包 -&gt; 发布程序<br>手头没有jenkins，而且刚好之前看到gitlab集成了ci功能，就想尝尝鲜。</p>\n<h2 id=\"配置构建环境\"><a href=\"#配置构建环境\" class=\"headerlink\" title=\"配置构建环境\"></a>配置构建环境</h2><p>经过研究，gitlab-ci采用分布式构建模式，也就是构建过程是跑在不同的构建主机上的。<br>构建主机需要运行gitlab-ci-runner进程，与gitlab服务端进行通信，以接收并执行分派给该进程的构建任务。<br>跑构建的主机上可以部署gitlab-ci-runner程序，使用gitlab项目中配置的token启动以后，该runner会自动出现在gitlab服务端的项目视图中。<br>进入gitlab项目页面-&gt;设置下拉列表-&gt;runners即可看到</p>\n<p>我厂的gitlab已经配置好了2个</p>\n<h2 id=\"创建构建配置文件\"><a href=\"#创建构建配置文件\" class=\"headerlink\" title=\"创建构建配置文件\"></a>创建构建配置文件</h2><p>gitlab-ci的构建过程是在配置文件中配置合描述的。<br>那么接下来，在项目根目录创建.gitlab-ci.yml文件<br>配置文件可以包含如下几个段落<br>variables<br>before_script<br>stages<br>build<br>我们的项目需要进行如下步骤<br>编译打包 -&gt; 发布程序<br>所以我们在build下面配置如下步骤<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build:</span><br><span class=\"line\">  stage: build</span><br><span class=\"line\">  script:</span><br><span class=\"line\">    - ./gradlew assembleRelease</span><br><span class=\"line\">    - DATE=`date +%Y%m%d%H%M%S`</span><br><span class=\"line\">    - rsync ./app/build/outputs/apk/app-release.apk work@publish-server:/home/work/data/www/publish-site/app/mtaa/mtaa_$&#123;DATE&#125;.apk</span><br><span class=\"line\">    - ssh work@publish-server &quot;cd /home/work/data/www/publish-site/app/mtaa; cp -f mtaa_$&#123;DATE&#125;.apk mtaa.apk&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  artifacts:</span><br><span class=\"line\">    paths:</span><br><span class=\"line\">    - app/build/outputs/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>构建过程<br>构建结果<br>发布结果<br>大家终于可以扫码下载最新版应用啦</p>\n"},{"title":"在PVE宿主机上访问KVM虚拟机镜像文件中的内容","date":"2017-03-02T06:54:27.000Z","_content":"\n## 问题背景\n\n在进行android项目构建尝试的过程中，遇到了一个棘手的问题。但是，在解决这个问题的过程中，引发了一个更为严重的结果。\n\n在android构建过程中，aapt报错:\n``` bash\nlibc.so.6: version `GLIBC_2.14` not found\n```\n\n运行命令，发现centos6下的libc版本只支持到2.12\n\n``` bash\n$ ldd --version\nldd (GNU) libc 2.12\n```\n\n然而，按照 此链接 所提供的信息升级libc库，安装完成并配置完环境变量*$LD_LIBRARY_PATH* 后，构建程序无响应，最后超时退出，看起来是卡在了什么地方。\n\n操作过程中注意到这样一句话，但是当时没在意。\n```\nYou cannot update glibc on Centos6 safely. \n```\n\n后来经过查询，尝试按照 此链接 提供的回答，尝试更改软连接的指向。\n``` bash\n$ ln -s /opt/glibc-2.14/lib/libc.so.6 /lib64/libc.so.6\n```\n\n然后，``这台机器就挂了``。对，就是这么突然，怎么也没想到兼容问题会如此严重。\n\n为了图方便，直接拿了测试环境的数据库主机来做实验，出现这种情况是始料未及的。出现问题后，因为服务不可用，好几个人过来找。捅了大篓子了 :(\n\n所以，为了继(bao)续(zhu)革(fan)命(wan)，至少要把数据库找回来。\n\n## 现象描述\n\n- 软连接建立完成后，尝试运行构建，片刻后失去响应，然后所有终端断开连接。\n- 在PVE管理平台上，看到该虚拟机处于io-error状态，CPU和内存图表数值陡将至极低，不波动。磁盘读写直接降为0。\n- 尝试在PVE管理平台重启，重启报错，无法操作恢复虚拟机状态。\n- 尝试登入宿主机，直接使用命令与宿主机通讯，依然报错。\n- 尝试重启宿主机，重启完毕后，该虚拟机启动成功。但是，一直无法ping通，说明网络服务无法启动，无法远程连接。\n- 全程慌得一比\n\n## 解决过程\n\n- 因为很笃定是由于修改libc的链接指向，导致问题的发生。所以解决问题的关键就是在于如何把这个文件再修改回去。\n- 但是如何修改一个无法登入的KVM虚拟机下面的文件，以前从来没有接触过这方面的操作，只知道KVM虚拟机会有一个镜像文件，和VM和vbox做的虚拟机镜像文件类似。\n- 登入宿主机，经过搜索发现了虚拟机镜像存储路径\n    ``` bash\n    /var/lib/vz/images/108/vm-108-disk-1.raw\n    ```\n    在这里补充一下，openvz虚拟机根目录的目录在如下路径，xxx为CT的ID\n    ``` base\n    /var/lib/vz/private/xxx/\n    ```\n- 找到了镜像文件，就考虑能否将该文件像虚拟光驱加载镜像一样挂载到某个目录，这样我们就可以进入这个镜像文件了，即使不能修改文件，至少可以把数据库文件拷贝出来\n- 经过一番搜寻，发现可以先将镜像文件映射至循环设备（``loop device``），然后挂载至文件系统，具体过程如下：\n    ``` bash\n    # 查找可用的loop device\n    root@pve:~# losetup -f\n    /dev/loop0\n\n    # 将镜像文件映射至该循环设备，也可以挂载img后缀的文件\n    root@pve:~# losetup /dev/loop0 /var/lib/vz/images/108/vm-108-disk-1.raw\n\n    # 因为急于求成，执行完本步骤后尝试挂载至文件系统，报错如下\n    root@pve:~# mount /dev/loop0 /mnt/108\n    mount: unknown filesystem type 'LVM2_member'\n\n    # 读取虚拟设备的分区\n    root@pve:~# kpartx -av /dev/loop0\n    add map loop0p1 : 0 7727202 linear /dev/loop0 63\n    add map loop0p2 : 0 449757 linear /dev/loop0 7727328\n\n    # 查看卷（volume）状态\n    root@pve:~# lvscan\n    inactive          '/dev/vg_ta/lv_root' [28.37 GiB] inherit\n    inactive          '/dev/vg_ta/lv_home' [25.26 GiB] inherit\n    inactive          '/dev/vg_ta/lv_swap' [5.88 GiB] inherit\n    \n    # 此时挂载会报错\n    root@pve:~# mount /dev/vg_ta/lv_root /mnt/108\n    mount: special device /dev/vg_ta/lv_root does not exist\n    \n    # 激活所有的卷\n    root@pve:~# vgchange -ay\n    3 logical volume(s) in volume group \"vg_ta\" now active\n\n    # 挂载成功\n    root@pve:~# mount /dev/vg_ta/lv_root /mnt/108\n\n    # 成功进入虚拟机文件系统\n    root@pve:~# ll /mnt/108\n    total 304\n    dr-xr-xr-x.  26 root root   4096 Mar  2 10:33 .\n    drwxr-xr-x    4 root root   4096 Mar  2 11:03 ..\n    dr-xr-xr-x.   2 root root   4096 Mar  2 03:45 bin\n    drwxr-xr-x.   2 root root   4096 Mar 20  2013 boot\n    drwxr-xr-x.   2 root root   4096 Sep 24  2011 cgroup\n    drwxr-xr-x.  16 root root   4096 Mar  1 18:17 data\n    drwxr-xr-x.   2 root root   4096 Mar 20  2013 dev\n    drwxr-xr-x. 103 root root  12288 Mar  2 10:33 etc\n    drwxr-xr-x.   2 root root   4096 Mar 20  2013 home\n    dr-xr-xr-x.  13 root root   4096 Mar  2 03:45 lib\n    ...\n\n    ```\n- 到此，心已经放到肚子里了\n    - 恢复libc软链接指向。\n    - 重启虚拟机\n    - 服务恢复正常\n\n## 心得\n\n- 实验性的操作要新开主机，不要嫌麻烦，否则真是得不偿失；\n- 底层类库升级要慎重，如果需要新版本类库特性，最好使用新版操作系统；\n- 数据库务必要备份，哪怕是开发或测试环境；\n\n## 扩展知识\n\n- linux系统中分区和卷的区别与联系\n    - 分区是基于物理磁盘的，是系统文件管理时识别用的磁盘地址，分区表是直接写在 MBR 或者 GPT 里面的，相对于卷来说更为底层。\n    - 卷是由LVM(Logical Volume Manager)进行管理，LVM是在磁盘分区和文件系统之间添加的一个逻辑层。通俗来讲就是把若干物理磁盘看为一个整体，在这个整体上进行逻辑分卷，以实现linux系统动态扩充磁盘容量的需求。\n    \n    ![LVM示意图](https://imgsa.baidu.com/baike/s%3D220/sign=0b4099b7b44543a9f11bfdce2e168a7b/8b13632762d0f70329d6d29f0bfa513d2697c509.jpg)\n\n- 什么是循环设备(loop device)\n    - 在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。\n    - 在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。\n    - 上面说的文件格式，我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 *.img 镜像文件。通过这种 loop mount (回环mount)的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。\n\n## 参考资料\n\n- [Accessing the contents of a KVM disk image](http://equivocation.org/node/107)\n- [How to mount LVM volumes, help!](http://www.fedoraforum.org/forum/archive/index.php/t-64964.html)\n- [mount: unknown filesystem type ‘LVM2_member’](http://pissedoffadmins.com/os/mount-unknown-filesystem-type-lvm2_member.html)\n- [linux下使用kpartx挂载虚拟文件系统](http://www.cnblogs.com/Jer-/p/3330128.html)\n- [loop设备及losetup命令介绍](http://blog.csdn.net/ustc_dylan/article/details/6878252)\n- [LVM - 百度百科](http://baike.baidu.com/item/LVM)","source":"_posts/access-contents-of-a-kvm-image.md","raw":"---\ntitle: 在PVE宿主机上访问KVM虚拟机镜像文件中的内容\ndate: 2017-03-02 14:54:27\ntags: [KVM, 虚拟机, 镜像, images, LVM]\ncategory: 工作日常\n---\n\n## 问题背景\n\n在进行android项目构建尝试的过程中，遇到了一个棘手的问题。但是，在解决这个问题的过程中，引发了一个更为严重的结果。\n\n在android构建过程中，aapt报错:\n``` bash\nlibc.so.6: version `GLIBC_2.14` not found\n```\n\n运行命令，发现centos6下的libc版本只支持到2.12\n\n``` bash\n$ ldd --version\nldd (GNU) libc 2.12\n```\n\n然而，按照 此链接 所提供的信息升级libc库，安装完成并配置完环境变量*$LD_LIBRARY_PATH* 后，构建程序无响应，最后超时退出，看起来是卡在了什么地方。\n\n操作过程中注意到这样一句话，但是当时没在意。\n```\nYou cannot update glibc on Centos6 safely. \n```\n\n后来经过查询，尝试按照 此链接 提供的回答，尝试更改软连接的指向。\n``` bash\n$ ln -s /opt/glibc-2.14/lib/libc.so.6 /lib64/libc.so.6\n```\n\n然后，``这台机器就挂了``。对，就是这么突然，怎么也没想到兼容问题会如此严重。\n\n为了图方便，直接拿了测试环境的数据库主机来做实验，出现这种情况是始料未及的。出现问题后，因为服务不可用，好几个人过来找。捅了大篓子了 :(\n\n所以，为了继(bao)续(zhu)革(fan)命(wan)，至少要把数据库找回来。\n\n## 现象描述\n\n- 软连接建立完成后，尝试运行构建，片刻后失去响应，然后所有终端断开连接。\n- 在PVE管理平台上，看到该虚拟机处于io-error状态，CPU和内存图表数值陡将至极低，不波动。磁盘读写直接降为0。\n- 尝试在PVE管理平台重启，重启报错，无法操作恢复虚拟机状态。\n- 尝试登入宿主机，直接使用命令与宿主机通讯，依然报错。\n- 尝试重启宿主机，重启完毕后，该虚拟机启动成功。但是，一直无法ping通，说明网络服务无法启动，无法远程连接。\n- 全程慌得一比\n\n## 解决过程\n\n- 因为很笃定是由于修改libc的链接指向，导致问题的发生。所以解决问题的关键就是在于如何把这个文件再修改回去。\n- 但是如何修改一个无法登入的KVM虚拟机下面的文件，以前从来没有接触过这方面的操作，只知道KVM虚拟机会有一个镜像文件，和VM和vbox做的虚拟机镜像文件类似。\n- 登入宿主机，经过搜索发现了虚拟机镜像存储路径\n    ``` bash\n    /var/lib/vz/images/108/vm-108-disk-1.raw\n    ```\n    在这里补充一下，openvz虚拟机根目录的目录在如下路径，xxx为CT的ID\n    ``` base\n    /var/lib/vz/private/xxx/\n    ```\n- 找到了镜像文件，就考虑能否将该文件像虚拟光驱加载镜像一样挂载到某个目录，这样我们就可以进入这个镜像文件了，即使不能修改文件，至少可以把数据库文件拷贝出来\n- 经过一番搜寻，发现可以先将镜像文件映射至循环设备（``loop device``），然后挂载至文件系统，具体过程如下：\n    ``` bash\n    # 查找可用的loop device\n    root@pve:~# losetup -f\n    /dev/loop0\n\n    # 将镜像文件映射至该循环设备，也可以挂载img后缀的文件\n    root@pve:~# losetup /dev/loop0 /var/lib/vz/images/108/vm-108-disk-1.raw\n\n    # 因为急于求成，执行完本步骤后尝试挂载至文件系统，报错如下\n    root@pve:~# mount /dev/loop0 /mnt/108\n    mount: unknown filesystem type 'LVM2_member'\n\n    # 读取虚拟设备的分区\n    root@pve:~# kpartx -av /dev/loop0\n    add map loop0p1 : 0 7727202 linear /dev/loop0 63\n    add map loop0p2 : 0 449757 linear /dev/loop0 7727328\n\n    # 查看卷（volume）状态\n    root@pve:~# lvscan\n    inactive          '/dev/vg_ta/lv_root' [28.37 GiB] inherit\n    inactive          '/dev/vg_ta/lv_home' [25.26 GiB] inherit\n    inactive          '/dev/vg_ta/lv_swap' [5.88 GiB] inherit\n    \n    # 此时挂载会报错\n    root@pve:~# mount /dev/vg_ta/lv_root /mnt/108\n    mount: special device /dev/vg_ta/lv_root does not exist\n    \n    # 激活所有的卷\n    root@pve:~# vgchange -ay\n    3 logical volume(s) in volume group \"vg_ta\" now active\n\n    # 挂载成功\n    root@pve:~# mount /dev/vg_ta/lv_root /mnt/108\n\n    # 成功进入虚拟机文件系统\n    root@pve:~# ll /mnt/108\n    total 304\n    dr-xr-xr-x.  26 root root   4096 Mar  2 10:33 .\n    drwxr-xr-x    4 root root   4096 Mar  2 11:03 ..\n    dr-xr-xr-x.   2 root root   4096 Mar  2 03:45 bin\n    drwxr-xr-x.   2 root root   4096 Mar 20  2013 boot\n    drwxr-xr-x.   2 root root   4096 Sep 24  2011 cgroup\n    drwxr-xr-x.  16 root root   4096 Mar  1 18:17 data\n    drwxr-xr-x.   2 root root   4096 Mar 20  2013 dev\n    drwxr-xr-x. 103 root root  12288 Mar  2 10:33 etc\n    drwxr-xr-x.   2 root root   4096 Mar 20  2013 home\n    dr-xr-xr-x.  13 root root   4096 Mar  2 03:45 lib\n    ...\n\n    ```\n- 到此，心已经放到肚子里了\n    - 恢复libc软链接指向。\n    - 重启虚拟机\n    - 服务恢复正常\n\n## 心得\n\n- 实验性的操作要新开主机，不要嫌麻烦，否则真是得不偿失；\n- 底层类库升级要慎重，如果需要新版本类库特性，最好使用新版操作系统；\n- 数据库务必要备份，哪怕是开发或测试环境；\n\n## 扩展知识\n\n- linux系统中分区和卷的区别与联系\n    - 分区是基于物理磁盘的，是系统文件管理时识别用的磁盘地址，分区表是直接写在 MBR 或者 GPT 里面的，相对于卷来说更为底层。\n    - 卷是由LVM(Logical Volume Manager)进行管理，LVM是在磁盘分区和文件系统之间添加的一个逻辑层。通俗来讲就是把若干物理磁盘看为一个整体，在这个整体上进行逻辑分卷，以实现linux系统动态扩充磁盘容量的需求。\n    \n    ![LVM示意图](https://imgsa.baidu.com/baike/s%3D220/sign=0b4099b7b44543a9f11bfdce2e168a7b/8b13632762d0f70329d6d29f0bfa513d2697c509.jpg)\n\n- 什么是循环设备(loop device)\n    - 在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。\n    - 在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。\n    - 上面说的文件格式，我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 *.img 镜像文件。通过这种 loop mount (回环mount)的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。\n\n## 参考资料\n\n- [Accessing the contents of a KVM disk image](http://equivocation.org/node/107)\n- [How to mount LVM volumes, help!](http://www.fedoraforum.org/forum/archive/index.php/t-64964.html)\n- [mount: unknown filesystem type ‘LVM2_member’](http://pissedoffadmins.com/os/mount-unknown-filesystem-type-lvm2_member.html)\n- [linux下使用kpartx挂载虚拟文件系统](http://www.cnblogs.com/Jer-/p/3330128.html)\n- [loop设备及losetup命令介绍](http://blog.csdn.net/ustc_dylan/article/details/6878252)\n- [LVM - 百度百科](http://baike.baidu.com/item/LVM)","slug":"access-contents-of-a-kvm-image","published":1,"updated":"2019-05-07T14:12:58.955Z","_id":"cjvdt6ria0001k7y9i09kpa1n","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>在进行android项目构建尝试的过程中，遇到了一个棘手的问题。但是，在解决这个问题的过程中，引发了一个更为严重的结果。</p>\n<p>在android构建过程中，aapt报错:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libc.so.6: version `GLIBC_2.14` not found</span><br></pre></td></tr></table></figure></p>\n<p>运行命令，发现centos6下的libc版本只支持到2.12</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ldd --version</span><br><span class=\"line\">ldd (GNU) libc 2.12</span><br></pre></td></tr></table></figure>\n<p>然而，按照 此链接 所提供的信息升级libc库，安装完成并配置完环境变量<em>$LD_LIBRARY_PATH</em> 后，构建程序无响应，最后超时退出，看起来是卡在了什么地方。</p>\n<p>操作过程中注意到这样一句话，但是当时没在意。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You cannot update glibc on Centos6 safely.</span><br></pre></td></tr></table></figure></p>\n<p>后来经过查询，尝试按照 此链接 提供的回答，尝试更改软连接的指向。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ln -s /opt/glibc-2.14/lib/libc.so.6 /lib64/libc.so.6</span><br></pre></td></tr></table></figure></p>\n<p>然后，<code>这台机器就挂了</code>。对，就是这么突然，怎么也没想到兼容问题会如此严重。</p>\n<p>为了图方便，直接拿了测试环境的数据库主机来做实验，出现这种情况是始料未及的。出现问题后，因为服务不可用，好几个人过来找。捅了大篓子了 :(</p>\n<p>所以，为了继(bao)续(zhu)革(fan)命(wan)，至少要把数据库找回来。</p>\n<h2 id=\"现象描述\"><a href=\"#现象描述\" class=\"headerlink\" title=\"现象描述\"></a>现象描述</h2><ul>\n<li>软连接建立完成后，尝试运行构建，片刻后失去响应，然后所有终端断开连接。</li>\n<li>在PVE管理平台上，看到该虚拟机处于io-error状态，CPU和内存图表数值陡将至极低，不波动。磁盘读写直接降为0。</li>\n<li>尝试在PVE管理平台重启，重启报错，无法操作恢复虚拟机状态。</li>\n<li>尝试登入宿主机，直接使用命令与宿主机通讯，依然报错。</li>\n<li>尝试重启宿主机，重启完毕后，该虚拟机启动成功。但是，一直无法ping通，说明网络服务无法启动，无法远程连接。</li>\n<li>全程慌得一比</li>\n</ul>\n<h2 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h2><ul>\n<li>因为很笃定是由于修改libc的链接指向，导致问题的发生。所以解决问题的关键就是在于如何把这个文件再修改回去。</li>\n<li>但是如何修改一个无法登入的KVM虚拟机下面的文件，以前从来没有接触过这方面的操作，只知道KVM虚拟机会有一个镜像文件，和VM和vbox做的虚拟机镜像文件类似。</li>\n<li><p>登入宿主机，经过搜索发现了虚拟机镜像存储路径</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/vz/images/108/vm-108-disk-1.raw</span><br></pre></td></tr></table></figure>\n<p>  在这里补充一下，openvz虚拟机根目录的目录在如下路径，xxx为CT的ID</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/vz/private/xxx/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找到了镜像文件，就考虑能否将该文件像虚拟光驱加载镜像一样挂载到某个目录，这样我们就可以进入这个镜像文件了，即使不能修改文件，至少可以把数据库文件拷贝出来</p>\n</li>\n<li><p>经过一番搜寻，发现可以先将镜像文件映射至循环设备（<code>loop device</code>），然后挂载至文件系统，具体过程如下：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查找可用的loop device</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># losetup -f</span></span><br><span class=\"line\">/dev/loop0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将镜像文件映射至该循环设备，也可以挂载img后缀的文件</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># losetup /dev/loop0 /var/lib/vz/images/108/vm-108-disk-1.raw</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为急于求成，执行完本步骤后尝试挂载至文件系统，报错如下</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># mount /dev/loop0 /mnt/108</span></span><br><span class=\"line\">mount: unknown filesystem <span class=\"built_in\">type</span> <span class=\"string\">'LVM2_member'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取虚拟设备的分区</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># kpartx -av /dev/loop0</span></span><br><span class=\"line\">add map loop0p1 : 0 7727202 linear /dev/loop0 63</span><br><span class=\"line\">add map loop0p2 : 0 449757 linear /dev/loop0 7727328</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看卷（volume）状态</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># lvscan</span></span><br><span class=\"line\">inactive          <span class=\"string\">'/dev/vg_ta/lv_root'</span> [28.37 GiB] inherit</span><br><span class=\"line\">inactive          <span class=\"string\">'/dev/vg_ta/lv_home'</span> [25.26 GiB] inherit</span><br><span class=\"line\">inactive          <span class=\"string\">'/dev/vg_ta/lv_swap'</span> [5.88 GiB] inherit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时挂载会报错</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># mount /dev/vg_ta/lv_root /mnt/108</span></span><br><span class=\"line\">mount: special device /dev/vg_ta/lv_root does not exist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活所有的卷</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># vgchange -ay</span></span><br><span class=\"line\">3 logical volume(s) <span class=\"keyword\">in</span> volume group <span class=\"string\">\"vg_ta\"</span> now active</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 挂载成功</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># mount /dev/vg_ta/lv_root /mnt/108</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 成功进入虚拟机文件系统</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># ll /mnt/108</span></span><br><span class=\"line\">total 304</span><br><span class=\"line\">dr-xr-xr-x.  26 root root   4096 Mar  2 10:33 .</span><br><span class=\"line\">drwxr-xr-x    4 root root   4096 Mar  2 11:03 ..</span><br><span class=\"line\">dr-xr-xr-x.   2 root root   4096 Mar  2 03:45 bin</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Mar 20  2013 boot</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Sep 24  2011 cgroup</span><br><span class=\"line\">drwxr-xr-x.  16 root root   4096 Mar  1 18:17 data</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Mar 20  2013 dev</span><br><span class=\"line\">drwxr-xr-x. 103 root root  12288 Mar  2 10:33 etc</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Mar 20  2013 home</span><br><span class=\"line\">dr-xr-xr-x.  13 root root   4096 Mar  2 03:45 lib</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>到此，心已经放到肚子里了</p>\n<ul>\n<li>恢复libc软链接指向。</li>\n<li>重启虚拟机</li>\n<li>服务恢复正常</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><ul>\n<li>实验性的操作要新开主机，不要嫌麻烦，否则真是得不偿失；</li>\n<li>底层类库升级要慎重，如果需要新版本类库特性，最好使用新版操作系统；</li>\n<li>数据库务必要备份，哪怕是开发或测试环境；</li>\n</ul>\n<h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><ul>\n<li><p>linux系统中分区和卷的区别与联系</p>\n<ul>\n<li>分区是基于物理磁盘的，是系统文件管理时识别用的磁盘地址，分区表是直接写在 MBR 或者 GPT 里面的，相对于卷来说更为底层。</li>\n<li><p>卷是由LVM(Logical Volume Manager)进行管理，LVM是在磁盘分区和文件系统之间添加的一个逻辑层。通俗来讲就是把若干物理磁盘看为一个整体，在这个整体上进行逻辑分卷，以实现linux系统动态扩充磁盘容量的需求。</p>\n<p><img src=\"https://imgsa.baidu.com/baike/s%3D220/sign=0b4099b7b44543a9f11bfdce2e168a7b/8b13632762d0f70329d6d29f0bfa513d2697c509.jpg\" alt=\"LVM示意图\"></p>\n</li>\n</ul>\n</li>\n<li><p>什么是循环设备(loop device)</p>\n<ul>\n<li>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。</li>\n<li>在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。</li>\n<li>上面说的文件格式，我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 *.img 镜像文件。通过这种 loop mount (回环mount)的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://equivocation.org/node/107\" target=\"_blank\" rel=\"noopener\">Accessing the contents of a KVM disk image</a></li>\n<li><a href=\"http://www.fedoraforum.org/forum/archive/index.php/t-64964.html\" target=\"_blank\" rel=\"noopener\">How to mount LVM volumes, help!</a></li>\n<li><a href=\"http://pissedoffadmins.com/os/mount-unknown-filesystem-type-lvm2_member.html\" target=\"_blank\" rel=\"noopener\">mount: unknown filesystem type ‘LVM2_member’</a></li>\n<li><a href=\"http://www.cnblogs.com/Jer-/p/3330128.html\" target=\"_blank\" rel=\"noopener\">linux下使用kpartx挂载虚拟文件系统</a></li>\n<li><a href=\"http://blog.csdn.net/ustc_dylan/article/details/6878252\" target=\"_blank\" rel=\"noopener\">loop设备及losetup命令介绍</a></li>\n<li><a href=\"http://baike.baidu.com/item/LVM\" target=\"_blank\" rel=\"noopener\">LVM - 百度百科</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>在进行android项目构建尝试的过程中，遇到了一个棘手的问题。但是，在解决这个问题的过程中，引发了一个更为严重的结果。</p>\n<p>在android构建过程中，aapt报错:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libc.so.6: version `GLIBC_2.14` not found</span><br></pre></td></tr></table></figure></p>\n<p>运行命令，发现centos6下的libc版本只支持到2.12</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ldd --version</span><br><span class=\"line\">ldd (GNU) libc 2.12</span><br></pre></td></tr></table></figure>\n<p>然而，按照 此链接 所提供的信息升级libc库，安装完成并配置完环境变量<em>$LD_LIBRARY_PATH</em> 后，构建程序无响应，最后超时退出，看起来是卡在了什么地方。</p>\n<p>操作过程中注意到这样一句话，但是当时没在意。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You cannot update glibc on Centos6 safely.</span><br></pre></td></tr></table></figure></p>\n<p>后来经过查询，尝试按照 此链接 提供的回答，尝试更改软连接的指向。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ln -s /opt/glibc-2.14/lib/libc.so.6 /lib64/libc.so.6</span><br></pre></td></tr></table></figure></p>\n<p>然后，<code>这台机器就挂了</code>。对，就是这么突然，怎么也没想到兼容问题会如此严重。</p>\n<p>为了图方便，直接拿了测试环境的数据库主机来做实验，出现这种情况是始料未及的。出现问题后，因为服务不可用，好几个人过来找。捅了大篓子了 :(</p>\n<p>所以，为了继(bao)续(zhu)革(fan)命(wan)，至少要把数据库找回来。</p>\n<h2 id=\"现象描述\"><a href=\"#现象描述\" class=\"headerlink\" title=\"现象描述\"></a>现象描述</h2><ul>\n<li>软连接建立完成后，尝试运行构建，片刻后失去响应，然后所有终端断开连接。</li>\n<li>在PVE管理平台上，看到该虚拟机处于io-error状态，CPU和内存图表数值陡将至极低，不波动。磁盘读写直接降为0。</li>\n<li>尝试在PVE管理平台重启，重启报错，无法操作恢复虚拟机状态。</li>\n<li>尝试登入宿主机，直接使用命令与宿主机通讯，依然报错。</li>\n<li>尝试重启宿主机，重启完毕后，该虚拟机启动成功。但是，一直无法ping通，说明网络服务无法启动，无法远程连接。</li>\n<li>全程慌得一比</li>\n</ul>\n<h2 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h2><ul>\n<li>因为很笃定是由于修改libc的链接指向，导致问题的发生。所以解决问题的关键就是在于如何把这个文件再修改回去。</li>\n<li>但是如何修改一个无法登入的KVM虚拟机下面的文件，以前从来没有接触过这方面的操作，只知道KVM虚拟机会有一个镜像文件，和VM和vbox做的虚拟机镜像文件类似。</li>\n<li><p>登入宿主机，经过搜索发现了虚拟机镜像存储路径</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/vz/images/108/vm-108-disk-1.raw</span><br></pre></td></tr></table></figure>\n<p>  在这里补充一下，openvz虚拟机根目录的目录在如下路径，xxx为CT的ID</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/vz/private/xxx/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找到了镜像文件，就考虑能否将该文件像虚拟光驱加载镜像一样挂载到某个目录，这样我们就可以进入这个镜像文件了，即使不能修改文件，至少可以把数据库文件拷贝出来</p>\n</li>\n<li><p>经过一番搜寻，发现可以先将镜像文件映射至循环设备（<code>loop device</code>），然后挂载至文件系统，具体过程如下：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查找可用的loop device</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># losetup -f</span></span><br><span class=\"line\">/dev/loop0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将镜像文件映射至该循环设备，也可以挂载img后缀的文件</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># losetup /dev/loop0 /var/lib/vz/images/108/vm-108-disk-1.raw</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 因为急于求成，执行完本步骤后尝试挂载至文件系统，报错如下</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># mount /dev/loop0 /mnt/108</span></span><br><span class=\"line\">mount: unknown filesystem <span class=\"built_in\">type</span> <span class=\"string\">'LVM2_member'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取虚拟设备的分区</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># kpartx -av /dev/loop0</span></span><br><span class=\"line\">add map loop0p1 : 0 7727202 linear /dev/loop0 63</span><br><span class=\"line\">add map loop0p2 : 0 449757 linear /dev/loop0 7727328</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看卷（volume）状态</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># lvscan</span></span><br><span class=\"line\">inactive          <span class=\"string\">'/dev/vg_ta/lv_root'</span> [28.37 GiB] inherit</span><br><span class=\"line\">inactive          <span class=\"string\">'/dev/vg_ta/lv_home'</span> [25.26 GiB] inherit</span><br><span class=\"line\">inactive          <span class=\"string\">'/dev/vg_ta/lv_swap'</span> [5.88 GiB] inherit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 此时挂载会报错</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># mount /dev/vg_ta/lv_root /mnt/108</span></span><br><span class=\"line\">mount: special device /dev/vg_ta/lv_root does not exist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活所有的卷</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># vgchange -ay</span></span><br><span class=\"line\">3 logical volume(s) <span class=\"keyword\">in</span> volume group <span class=\"string\">\"vg_ta\"</span> now active</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 挂载成功</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># mount /dev/vg_ta/lv_root /mnt/108</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 成功进入虚拟机文件系统</span></span><br><span class=\"line\">root@pve:~<span class=\"comment\"># ll /mnt/108</span></span><br><span class=\"line\">total 304</span><br><span class=\"line\">dr-xr-xr-x.  26 root root   4096 Mar  2 10:33 .</span><br><span class=\"line\">drwxr-xr-x    4 root root   4096 Mar  2 11:03 ..</span><br><span class=\"line\">dr-xr-xr-x.   2 root root   4096 Mar  2 03:45 bin</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Mar 20  2013 boot</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Sep 24  2011 cgroup</span><br><span class=\"line\">drwxr-xr-x.  16 root root   4096 Mar  1 18:17 data</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Mar 20  2013 dev</span><br><span class=\"line\">drwxr-xr-x. 103 root root  12288 Mar  2 10:33 etc</span><br><span class=\"line\">drwxr-xr-x.   2 root root   4096 Mar 20  2013 home</span><br><span class=\"line\">dr-xr-xr-x.  13 root root   4096 Mar  2 03:45 lib</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>到此，心已经放到肚子里了</p>\n<ul>\n<li>恢复libc软链接指向。</li>\n<li>重启虚拟机</li>\n<li>服务恢复正常</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><ul>\n<li>实验性的操作要新开主机，不要嫌麻烦，否则真是得不偿失；</li>\n<li>底层类库升级要慎重，如果需要新版本类库特性，最好使用新版操作系统；</li>\n<li>数据库务必要备份，哪怕是开发或测试环境；</li>\n</ul>\n<h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><ul>\n<li><p>linux系统中分区和卷的区别与联系</p>\n<ul>\n<li>分区是基于物理磁盘的，是系统文件管理时识别用的磁盘地址，分区表是直接写在 MBR 或者 GPT 里面的，相对于卷来说更为底层。</li>\n<li><p>卷是由LVM(Logical Volume Manager)进行管理，LVM是在磁盘分区和文件系统之间添加的一个逻辑层。通俗来讲就是把若干物理磁盘看为一个整体，在这个整体上进行逻辑分卷，以实现linux系统动态扩充磁盘容量的需求。</p>\n<p><img src=\"https://imgsa.baidu.com/baike/s%3D220/sign=0b4099b7b44543a9f11bfdce2e168a7b/8b13632762d0f70329d6d29f0bfa513d2697c509.jpg\" alt=\"LVM示意图\"></p>\n</li>\n</ul>\n</li>\n<li><p>什么是循环设备(loop device)</p>\n<ul>\n<li>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。</li>\n<li>在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。</li>\n<li>上面说的文件格式，我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 *.img 镜像文件。通过这种 loop mount (回环mount)的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://equivocation.org/node/107\" target=\"_blank\" rel=\"noopener\">Accessing the contents of a KVM disk image</a></li>\n<li><a href=\"http://www.fedoraforum.org/forum/archive/index.php/t-64964.html\" target=\"_blank\" rel=\"noopener\">How to mount LVM volumes, help!</a></li>\n<li><a href=\"http://pissedoffadmins.com/os/mount-unknown-filesystem-type-lvm2_member.html\" target=\"_blank\" rel=\"noopener\">mount: unknown filesystem type ‘LVM2_member’</a></li>\n<li><a href=\"http://www.cnblogs.com/Jer-/p/3330128.html\" target=\"_blank\" rel=\"noopener\">linux下使用kpartx挂载虚拟文件系统</a></li>\n<li><a href=\"http://blog.csdn.net/ustc_dylan/article/details/6878252\" target=\"_blank\" rel=\"noopener\">loop设备及losetup命令介绍</a></li>\n<li><a href=\"http://baike.baidu.com/item/LVM\" target=\"_blank\" rel=\"noopener\">LVM - 百度百科</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjvdt6ria0001k7y9i09kpa1n","category_id":"cjvdtcrrx000uk7y9a7kkfaxd","_id":"cjvdtcrrx000vk7y9xtokf8ey"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","category_id":"cjvdtcrrx000uk7y9a7kkfaxd","_id":"cjvdtcwgs000wk7y9h5vzyiew"}],"PostTag":[{"post_id":"cjvdssy830002fjy9zgg80ip0","tag_id":"cjvdssy840003fjy9llay4kcn","_id":"cjvdssy860004fjy99tu5vp8h"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rif0003k7y9034xrr66","_id":"cjvdt6rik000ek7y9xqmu7o4n"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rig0005k7y9mkopifxk","_id":"cjvdt6rik000fk7y9du18p5me"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rii0007k7y9vdmyazvo","_id":"cjvdt6rik000hk7y9rv6valgz"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rii0009k7y9vntb4kfg","_id":"cjvdt6rik000ik7y9woq0fcsj"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rij000ak7y9e7dp6y5g","_id":"cjvdt6ril000kk7y9t22sk0ee"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rij000bk7y9hckeuc7l","_id":"cjvdt6ril000lk7y95glt3ufq"},{"post_id":"cjvdt6ri60000k7y9elth9mzc","tag_id":"cjvdt6rij000ck7y9k6kuwkkm","_id":"cjvdt6ril000nk7y93v6wggf9"},{"post_id":"cjvdt6ria0001k7y9i09kpa1n","tag_id":"cjvdt6rij000dk7y9q75ft1b7","_id":"cjvdt6rim000pk7y997hep1w8"},{"post_id":"cjvdt6ria0001k7y9i09kpa1n","tag_id":"cjvdt6rik000gk7y9dxf1k4mh","_id":"cjvdt6rim000qk7y935ndcrps"},{"post_id":"cjvdt6ria0001k7y9i09kpa1n","tag_id":"cjvdt6ril000jk7y96om7lesy","_id":"cjvdt6rim000rk7y91reuzjfw"},{"post_id":"cjvdt6ria0001k7y9i09kpa1n","tag_id":"cjvdt6ril000mk7y9pd0scsi1","_id":"cjvdt6rim000sk7y9qhul5ele"},{"post_id":"cjvdt6ria0001k7y9i09kpa1n","tag_id":"cjvdt6ril000ok7y9oslllh5e","_id":"cjvdt6rim000tk7y9h8zn4r5y"}],"Tag":[{"name":"feafe","_id":"cjvdssy840003fjy9llay4kcn"},{"name":"gitlab","_id":"cjvdt6rif0003k7y9034xrr66"},{"name":"ci","_id":"cjvdt6rig0005k7y9mkopifxk"},{"name":"gitlab-ci","_id":"cjvdt6rii0007k7y9vdmyazvo"},{"name":"android","_id":"cjvdt6rii0009k7y9vntb4kfg"},{"name":"build","_id":"cjvdt6rij000ak7y9e7dp6y5g"},{"name":"构建","_id":"cjvdt6rij000bk7y9hckeuc7l"},{"name":"打包","_id":"cjvdt6rij000ck7y9k6kuwkkm"},{"name":"KVM","_id":"cjvdt6rij000dk7y9q75ft1b7"},{"name":"虚拟机","_id":"cjvdt6rik000gk7y9dxf1k4mh"},{"name":"镜像","_id":"cjvdt6ril000jk7y96om7lesy"},{"name":"images","_id":"cjvdt6ril000mk7y9pd0scsi1"},{"name":"LVM","_id":"cjvdt6ril000ok7y9oslllh5e"}]}}